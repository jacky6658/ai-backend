# app.py
import os
import json
import glob
import sqlite3
from typing import List, Optional, Any, Dict

from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, HTMLResponse, Response, StreamingResponse

# ========= ç’°å¢ƒè®Šæ•¸ =========
DB_PATH = os.getenv("DB_PATH", "/data/script_generation.db")
GEMINI_MODEL = os.getenv("GEMINI_MODEL", "gemini-1.5-flash")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY") or os.getenv("GOOGLE_API_KEY")

# ========= App èˆ‡ CORS =========
app = FastAPI(title="AI Script + Copy Backend")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["POST", "OPTIONS", "GET"],
    allow_headers=["*"],
)

# ========= DB =========
def _ensure_db_dir(path: str):
    os.makedirs(os.path.dirname(path) or ".", exist_ok=True)

def get_conn() -> sqlite3.Connection:
    _ensure_db_dir(DB_PATH)
    return sqlite3.connect(DB_PATH, check_same_thread=False)

def init_db():
    _ensure_db_dir(DB_PATH)
    conn = get_conn()
    cur = conn.cursor()
    cur.execute("""
        CREATE TABLE IF NOT EXISTS requests (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
            user_input TEXT,
            mode TEXT,
            messages_json TEXT,
            previous_segments_json TEXT,
            response_json TEXT
        )
    """)
    conn.commit()
    conn.close()

@app.on_event("startup")
def on_startup():
    try:
        init_db()
        print(f"[BOOT] DB ready at {DB_PATH}")
    except Exception as e:
        print("[BOOT] DB init failed:", e)

@app.get("/healthz")
def healthz(): return {"ok": True}

@app.get("/favicon.ico")
def favicon(): return Response(status_code=204)

@app.get("/", response_class=HTMLResponse)
def root_page():
    return """
    <html><body>
      <h3>AI Backend OK</h3>
      <p>POST <code>/chat_generate</code>ï¼ˆè…³æœ¬/æ–‡æ¡ˆäºŒåˆä¸€ï¼‰</p>
      <p>POST <code>/generate_script</code>ï¼ˆèˆŠæµç¨‹ä¿ç•™ï¼‰</p>
      <p>POST <code>/export/xlsx</code> åŒ¯å‡º Excelï¼›<code>/export/docx</code> æš«åœï¼ˆ501ï¼‰ã€‚</p>
      <p>æ–‡æ¡ˆæ¨¡å¼ï¼šå›å‚³ç‰©ä»¶å« <code>image_ideas</code>ï¼ˆåœ–ç‰‡/è¦–è¦ºå»ºè­°ï¼‰ã€‚</p>
    </body></html>
    """

# ========= å…§å»ºçŸ¥è­˜åº« =========
BUILTIN_KB_SCRIPT = """
ã€çŸ­å½±éŸ³è…³æœ¬åŸå‰‡ï¼ˆæ¿ƒç¸®ï¼‰ã€‘
1) Hook(0-5s) â†’ Value(5-25s å¯å»¶ä¼¸) â†’ CTAã€‚
2) æ¯æ®µè¼¸å‡ºï¼štype/start_sec/end_sec/camera/dialog/visual/ctaã€‚
3) Hook ç”¨ç—›é»/åå·®/æ•¸æ“šé‰¤å­ + å¿«ç¯€å¥ B-rollï¼›Value æ‹† 3 é»ä»¥å…§ï¼›CTA å‹•è©+åˆ©ç›Š+ä¸‹ä¸€æ­¥ã€‚
4) èªæ°£å£èªã€çŸ­å¥ã€æœ‰ç¯€å¥ï¼Œé¿å…ç©ºè©±ã€‚
"""

BUILTIN_KB_COPY = """
ã€ç¤¾ç¾¤æ–‡æ¡ˆåŸå‰‡ï¼ˆæ¿ƒç¸®ï¼‰ã€‘
1) çµæ§‹ï¼šå¸ç›é–‹é ­ â†’ ä¸»é«”è³£é»/æ•…äº‹ â†’ CTA â†’ Hashtagsã€‚
2) é¢¨æ ¼ï¼šè²¼è¿‘å—çœ¾ã€çŸ­å¥ã€å¯æ­ emojiã€çµå°¾æœ‰å‹•ä½œã€‚
3) Hashtagsï¼šä¸»é—œéµå­— 1-3ã€å»¶ä¼¸ 5-8ã€‚
4) æ¬„ä½ï¼šmain_copy / alternates / hashtags / cta / image_ideasï¼ˆå¹³å°åŒ–åœ–ç‰‡å»ºè­°ï¼‰ã€‚
"""

def load_extra_kb(max_chars=2500) -> str:
    paths = glob.glob("/data/kb*.txt") + glob.glob("/data/*.kb.txt") + glob.glob("/data/knowledge*.txt")
    chunks, total = [], 0
    for p in paths:
        try:
            t = open(p, "r", encoding="utf-8").read().strip()
            if not t: continue
            take = (max_chars - total)
            seg = t[:take]
            if seg:
                chunks.append(f"\n[KB:{os.path.basename(p)}]\n{seg}")
                total += len(seg)
            if total >= max_chars: break
        except Exception:
            pass
    return "\n".join(chunks)

EXTRA_KB = load_extra_kb()

# ========= æç¤ºå­— & å·¥å…· =========
SHORT_HINT_SCRIPT = "å…§å®¹æœ‰é»å¤ªçŸ­äº† ğŸ™ è«‹æä¾›ï¼šè¡Œæ¥­/å¹³å°/æ™‚é•·(ç§’)/ç›®æ¨™/ä¸»é¡Œï¼ˆä¾‹å¦‚ï¼šã€é›»å•†ï½œReelsï½œ30ç§’ï½œè³¼è²·ï½œå¤å­£æ–°å“é–‹ç®±ã€ï¼‰ï¼Œæˆ‘å°±èƒ½ç”Ÿæˆå®Œæ•´è…³æœ¬ã€‚"
SHORT_HINT_COPY   = "å…§å®¹æœ‰é»å¤ªçŸ­äº† ğŸ™ è«‹æä¾›ï¼šå¹³å°/å—çœ¾/èªæ°£/ä¸»é¡Œ/CTAï¼ˆä¾‹å¦‚ï¼šã€IGï½œç”·ç”Ÿè¦–è§’ï½œæ´»åŠ›å›æ­¸ï½œCTAï¼šé»é€£çµã€ï¼‰ï¼Œæˆ‘å°±èƒ½ç”Ÿæˆå®Œæ•´è²¼æ–‡ã€‚"

def _ensure_json_block(text: str) -> str:
    if not text: raise ValueError("empty model output")
    t = text.strip()
    if t.startswith("```"):
        parts = t.split("```")
        if len(parts) >= 3: t = parts[1]
    i = min([x for x in (t.find("{"), t.find("[")) if x >= 0], default=-1)
    if i < 0: return t
    j = max(t.rfind("}"), t.rfind("]"))
    if j > i: return t[i:j+1]
    return t

def detect_mode(messages: List[Dict[str, str]], explicit: Optional[str]) -> str:
    """å„ªå…ˆä½¿ç”¨ explicitï¼›å¦å‰‡ç”¨é—œéµå­—åˆ¤æ–·ã€‚"""
    if explicit in ("script", "copy"):
        return explicit
    last = ""
    for m in reversed(messages or []):
        if m.get("role") == "user":
            last = (m.get("content") or "").lower()
            break
    copy_keys = [
        "æ–‡æ¡ˆ","è²¼æ–‡","copy","hashtag","hashtags",
        "ig","facebook","fb","linkedin","å°ç´…æ›¸","xï¼ˆtwitterï¼‰","x/twitter","æŠ–éŸ³æ–‡æ¡ˆ"
    ]
    if any(k in last for k in copy_keys):
        return "copy"
    return "script"

def parse_segments(json_text: str) -> List[Dict[str, Any]]:
    data = json.loads(json_text)
    if isinstance(data, dict) and "segments" in data: data = data["segments"]
    if not isinstance(data, list): raise ValueError("segments must be a list")
    segs = []
    for it in data:
        segs.append({
            "type": it.get("type") or it.get("label") or "å ´æ™¯",
            "start_sec": it.get("start_sec", None),
            "end_sec": it.get("end_sec", None),
            "camera": it.get("camera", ""),
            "dialog": it.get("dialog", ""),
            "visual": it.get("visual", ""),
            "cta": it.get("cta", "")
        })
    return segs

def parse_copy(json_text: str) -> Dict[str, Any]:
    data = json.loads(json_text)
    if isinstance(data, list): data = data[0] if data else {}
    return {
        "main_copy":   data.get("main_copy", ""),
        "alternates":  data.get("alternates", []) or data.get("openers", []),
        "hashtags":    data.get("hashtags", []),
        "cta":         data.get("cta", ""),
        "image_ideas": data.get("image_ideas", [])
    }

def build_script_prompt(user_input: str, previous_segments: List[Dict[str, Any]]) -> str:
    fewshot = """
{"segments":[
  {"type":"hook","start_sec":0,"end_sec":5,"camera":"CU","dialog":"...","visual":"...","cta":""},
  {"type":"value","start_sec":5,"end_sec":25,"camera":"MS","dialog":"...","visual":"...","cta":""},
  {"type":"cta","start_sec":25,"end_sec":30,"camera":"WS","dialog":"...","visual":"...","cta":"..."}
]}
"""
    prev = json.dumps(previous_segments or [], ensure_ascii=False)
    kb = (BUILTIN_KB_SCRIPT + "\n" + (EXTRA_KB or "")).strip()
    return f"""
ä½ æ˜¯çŸ­å½±éŸ³è…³æœ¬é¡§å•ã€‚è«‹æ ¹æ“šã€Œä½¿ç”¨è€…è¼¸å…¥ã€èˆ‡ã€Œå·²æ¥å—æ®µè½ã€å»¶çºŒæˆ–é‡å¯«ï¼Œè¼¸å‡º JSONï¼ˆç¦æ­¢é¡å¤–èªªæ˜æ–‡å­—ï¼‰ã€‚

{kb}

ä½¿ç”¨è€…è¼¸å…¥ï¼š
{user_input}

å·²æ¥å—æ®µè½ï¼š
{prev}

åªå›å‚³ JSONï¼š
{fewshot}
"""

def build_copy_prompt(user_input: str, topic: Optional[str]) -> str:
    topic_line = f"\nã€ä¸»é¡Œã€‘{topic}" if topic else ""
    fewshot = """
{
  "main_copy":"ä¸»è²¼æ–‡ï¼ˆå«æ›è¡Œèˆ‡ emojiï¼‰",
  "alternates":["å‚™é¸é–‹é ­A","å‚™é¸é–‹é ­B","å‚™é¸é–‹é ­C"],
  "hashtags":["#é—œéµå­—1","#é—œéµå­—2","#å»¶ä¼¸3","#å»¶ä¼¸4"],
  "cta":"è¡Œå‹•å‘¼ç±²ä¸€å¥è©±",
  "image_ideas":["é…åœ–/ç…§ç‰‡/ç¤ºæ„åœ–å»ºè­°1","å»ºè­°2","å»ºè­°3"]
}
"""
    kb = (BUILTIN_KB_COPY + "\n" + (EXTRA_KB or "")).strip()
    return f"""
ä½ æ˜¯ç¤¾ç¾¤æ–‡æ¡ˆé¡§å•ã€‚è«‹ä¾ã€Œä½¿ç”¨è€…è¼¸å…¥ã€èˆ‡å¯é¸çš„ä¸»é¡Œè¼¸å‡º**JSON**ï¼ŒåŒ…å«ä¸»è²¼æ–‡ã€å‚™é¸é–‹é ­ã€Hashtagsã€CTAï¼Œä¸¦åŠ å…¥ image_ideasï¼ˆå¹³å°å°å‘çš„åœ–ç‰‡/æ‹æ³•/è¦–è¦ºå»ºè­°ï¼‰ã€‚èªæ°£å¯å£èªä¸¦é©åº¦ä½¿ç”¨ emojiã€‚

{kb}

ä½¿ç”¨è€…è¼¸å…¥ï¼š
{user_input}{topic_line}

åªå›å‚³ JSONï¼ˆå–®ä¸€ç‰©ä»¶ï¼Œä¸è¦ markdown fenceï¼‰ï¼š
{fewshot}
"""

# ========= Gemini =========
def use_gemini() -> bool: return bool(GEMINI_API_KEY)

def gemini_generate_text(prompt: str) -> str:
    import google.generativeai as genai
    genai.configure(api_key=GEMINI_API_KEY)
    model = genai.GenerativeModel(GEMINI_MODEL)
    res = model.generate_content(prompt)
    return (res.text or "").strip()

# ========= Fallback =========
def fallback_segments(user_input: str, prev_len: int) -> List[Dict[str, Any]]:
    step = prev_len
    return [{
        "type": "hook" if step == 0 else ("cta" if step >= 2 else "value"),
        "start_sec": 0 if step == 0 else 5 if step == 1 else 25,
        "end_sec":   5 if step == 0 else 25 if step == 1 else 30,
        "camera": "CU" if step == 0 else "MS" if step == 1 else "WS",
        "dialog": f"ï¼ˆæ¨¡æ“¬ï¼‰{user_input[:36]}â€¦",
        "visual": "ï¼ˆæ¨¡æ“¬ï¼‰å¿«åˆ‡ B-roll / å¤§å­—å¡",
        "cta": "é»é€£çµé ˜å– ğŸ”—" if step >= 2 else ""
    }]

def fallback_copy(user_input: str, topic: Optional[str]) -> Dict[str, Any]:
    t = f"ï¼ˆä¸»é¡Œï¼š{topic}ï¼‰" if topic else ""
    return {
        "main_copy":  f"ï¼ˆæ¨¡æ“¬ï¼‰IG è²¼æ–‡ï¼š{user_input} {t}\nç²¾ç¥å›æ­¸ã€æ•ˆç‡å›å‡ï¼âš¡ï¸\nä»Šå¤©å°±è¡Œå‹•å§ï¼",
        "alternates": ["ğŸ”¥ ä»Šå¤©å°±é–‹å§‹","ğŸ’¡ å…¶å¯¦åªè¦é€™æ¨£åš","ğŸ‘‰ ä½ ä¹Ÿå¯ä»¥"],
        "hashtags":   ["#è¡ŒéŠ·","#AI","#æ–‡æ¡ˆ","#ç¤¾ç¾¤ç¶“ç‡Ÿ"],
        "cta":        "ç«‹å³é»é€£çµ ğŸ”—",
        "image_ideas":["ç”¢å“è¿‘æ‹ + ç”Ÿæ´»æƒ…å¢ƒ","å“ç‰Œè‰²èƒŒæ™¯å¤§å­—å¡","æ­¥é©Ÿæµç¨‹ç¤ºæ„åœ–"]
    }

# ========= /chat_generate =========
@app.post("/chat_generate")
async def chat_generate(req: Request):
    """
    body: {
      user_id?: str,
      session_id?: str,
      messages: [{role, content}],
      previous_segments?: [segment...],
      remember?: bool,
      mode?: "script" | "copy",    # â† å‰ç«¯å¼·åˆ¶å¸¶å…¥é¿å…èª¤åˆ¤
      topic?: str                  # â† æ–‡æ¡ˆä¸»é¡Œï¼ˆå¯é¸ï¼‰
    }
    """
    try:
        data = await req.json()
    except Exception:
        raise HTTPException(status_code=422, detail="invalid_json")

    user_id = (data.get("user_id") or "").strip() or "web"
    messages = data.get("messages") or []
    previous_segments = data.get("previous_segments") or []
    topic = (data.get("topic") or "").strip() or None

    explicit_mode = (data.get("mode") or "").strip().lower() or None
    mode = detect_mode(messages, explicit=explicit_mode)

    user_input = ""
    for m in reversed(messages):
        if m.get("role") == "user":
            user_input = (m.get("content") or "").strip()
            break

    # é‡å° copy èˆ‡ script åˆ†æµçŸ­å­—æç¤º
    hint = SHORT_HINT_COPY if mode == "copy" else SHORT_HINT_SCRIPT
    if len(user_input) < 6:
        return {
            "session_id": data.get("session_id") or "s",
            "assistant_message": hint,
            "segments": [],
            "copy": None,
            "error": None
        }

    try:
        if mode == "copy":
            prompt = build_copy_prompt(user_input, topic)
            if use_gemini():
                out = gemini_generate_text(prompt)
                j = _ensure_json_block(out)
                copy = parse_copy(j)
            else:
                copy = fallback_copy(user_input, topic)

            resp = {
                "session_id": data.get("session_id") or "s",
                "assistant_message": "æˆ‘å…ˆçµ¦ä½ ç¬¬ä¸€ç‰ˆå®Œæ•´è²¼æ–‡ï¼ˆå¯å†åŠ è¦æ±‚ï¼Œæˆ‘æœƒå¹«ä½ æ”¹å¾—æ›´è²¼è¿‘é¢¨æ ¼ï¼‰ã€‚",
                "segments": [],
                "copy": copy,
                "error": None
            }

        else:  # script
            prompt = build_script_prompt(user_input, previous_segments)
            if use_gemini():
                out = gemini_generate_text(prompt)
                j = _ensure_json_block(out)
                segments = parse_segments(j)
            else:
                segments = fallback_segments(user_input, len(previous_segments or []))

            resp = {
                "session_id": data.get("session_id") or "s",
                "assistant_message": "æˆ‘å…ˆçµ¦ä½ ç¬¬ä¸€ç‰ˆå®Œæ•´è…³æœ¬ï¼ˆå¯å†åŠ è¦æ±‚ï¼Œæˆ‘æœƒå¹«ä½ æ”¹å¾—æ›´è²¼è¿‘é¢¨æ ¼ï¼‰ã€‚",
                "segments": segments,
                "copy": None,
                "error": None
            }

        # DB ç´€éŒ„
        try:
            conn = get_conn()
            cur = conn.cursor()
            cur.execute(
                "INSERT INTO requests (user_input, mode, messages_json, previous_segments_json, response_json) VALUES (?, ?, ?, ?, ?)",
                (
                    user_input, mode,
                    json.dumps(messages, ensure_ascii=False),
                    json.dumps(previous_segments, ensure_ascii=False),
                    json.dumps(resp, ensure_ascii=False),
                ),
            )
            conn.commit()
            conn.close()
        except Exception as e:
            print("[DB] insert failed:", e)

        return resp

    except Exception as e:
        print("[chat_generate] error:", e)
        return JSONResponse(status_code=500, content={
            "session_id": data.get("session_id") or "s",
            "assistant_message": "ä¼ºæœå™¨å¿™ç¢Œï¼Œç¨å¾Œå†è©¦",
            "segments": [],
            "copy": None,
            "error": "internal_server_error"
        })

# ========= èˆŠæµç¨‹ï¼š/generate_script =========
@app.post("/generate_script")
async def generate_script(req: Request):
    try:
        data = await req.json()
    except Exception:
        raise HTTPException(status_code=422, detail="invalid_json")

    user_input = (data.get("user_input") or "").strip()
    previous_segments = data.get("previous_segments") or []

    if len(user_input) < 6:
        return {"segments": [], "error": SHORT_HINT_SCRIPT}

    try:
        prompt = build_script_prompt(user_input, previous_segments)
        if use_gemini():
            out = gemini_generate_text(prompt)
            j = _ensure_json_block(out)
            segments = parse_segments(j)
        else:
            segments = fallback_segments(user_input, len(previous_segments or []))
        return {"segments": segments, "error": None}
    except Exception as e:
        print("[generate_script] error:", e)
        return JSONResponse(status_code=500, content={"segments": [], "error": "internal_server_error"})

# ========= åŒ¯å‡ºï¼šWord æš«åœ / Excel ä¿ç•™ =========
@app.post("/export/docx")
async def export_docx_disabled():
    # å…ˆåœç”¨ï¼šé¿å…å‰ç«¯èª¤æŒ‰å°è‡´éŒ¯èª¤ï¼›ä¹‹å¾Œè¦é–‹å†å¯¦ä½œ
    return JSONResponse(status_code=501, content={"error": "docx_export_disabled"})

def _ensure_xlsx():
    try:
        import openpyxl  # noqa
        return True
    except Exception:
        return False

@app.post("/export/xlsx")
async def export_xlsx(req: Request):
    if not _ensure_xlsx():
        return JSONResponse(status_code=501, content={"error": "xlsx_not_available"})
    import openpyxl
    from openpyxl.utils import get_column_letter
    from io import BytesIO

    data = await req.json()
    segments = data.get("segments") or []
    copy = data.get("copy") or None

    wb = openpyxl.Workbook()
    ws1 = wb.active; ws1.title = "è…³æœ¬åˆ†æ®µ"
    ws1.append(["#","type","start_sec","end_sec","camera","dialog","visual","cta"])
    for i, s in enumerate(segments, 1):
        ws1.append([i, s.get("type"), s.get("start_sec"), s.get("end_sec"),
                    s.get("camera"), s.get("dialog"), s.get("visual"), s.get("cta")])

    ws2 = wb.create_sheet("æ–‡æ¡ˆ")
    ws2.append(["ä¸»è²¼æ–‡"]); ws2.append([copy.get("main_copy") if copy else ""])
    ws2.append([]); ws2.append(["å‚™é¸é–‹é ­"])
    for a in (copy.get("alternates") if copy else []) or []: ws2.append([a])
    ws2.append([]); ws2.append(["Hashtags"])
    ws2.append([" ".join(copy.get("hashtags") if copy else [])])
    ws2.append([]); ws2.append(["CTA"])
    ws2.append([copy.get("cta") if copy else ""])
    ws2.append([]); ws2.append(["åœ–ç‰‡å»ºè­°"])
    for idea in (copy.get("image_ideas") if copy else []) or []: ws2.append([idea])

    for ws in (ws1, ws2):
        for col in ws.columns:
            width = max(len(str(c.value)) if c.value else 0 for c in col) + 2
            ws.column_dimensions[get_column_letter(col[0].column)].width = min(width, 80)

    bio = BytesIO(); wb.save(bio); bio.seek(0)
    return StreamingResponse(
        bio,
        media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        headers={"Content-Disposition": 'attachment; filename="export.xlsx"'}
    )
# ========= CSV ä¸‹è¼‰ & Google Sheet é€£å‹• =========
import csv
from fastapi.responses import FileResponse

@app.get("/download/requests_export.csv")
def download_requests_csv():
    """åŒ¯å‡ºè³‡æ–™åº« requests è¡¨ç‚º CSV æª”ï¼Œæ–¹ä¾¿æ‰‹å‹•ä¸‹è¼‰æˆ–å‚™ä»½"""
    export_path = "/data/requests_export.csv"
    conn = get_conn()
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM requests ORDER BY id DESC")
    rows = cursor.fetchall()
    headers = [desc[0] for desc in cursor.description]
    conn.close()

    with open(export_path, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        writer.writerow(headers)
        writer.writerows(rows)

    return FileResponse(
        export_path,
        media_type="text/csv",
        filename="requests_export.csv"
    )


@app.get("/export/google-sheet")
def export_for_google_sheet(limit: int = 100):
    """
    çµ¦ Google Sheet ç”¨çš„ç°¡åŒ–åŒ¯å‡ºã€‚
    å¯ä»¥åœ¨ Google Sheet è£¡ç”¨ï¼š
      =IMPORTDATA("https://ä½ çš„ç¶²åŸŸ/export/google-sheet?limit=50")
    """
    conn = get_conn()
    cursor = conn.cursor()
    cursor.execute(
        "SELECT id, created_at, user_input, mode FROM requests ORDER BY id DESC LIMIT ?",
        (limit,)
    )
    rows = cursor.fetchall()
    conn.close()

    from io import StringIO
    output = StringIO()
    writer = csv.writer(output)
    writer.writerow(["id", "created_at", "user_input", "mode"])
    for row in rows:
        writer.writerow(row)
    return Response(content=output.getvalue(), media_type="text/csv")
@app.get("/export/google-sheet-flat")
def export_google_sheet_flat(limit: int = 200):
    """
    æ‰å¹³ç‰ˆ CSVï¼šæŠŠå¸¸ç”¨æ¬„ä½æ”¤å¹³ï¼ŒGoogle Sheet ç›´æ¥è®€å°±ä¹¾æ·¨ã€‚
    ä¾‹ï¼š=IMPORTDATA("https://aijobvideobackend.zeabur.app/export/google-sheet-flat?limit=200")
    """
    import csv
    from io import StringIO

    # 1) å®‰å…¨è™•ç† limit
    try:
        limit = int(limit)
    except Exception:
        limit = 200
    limit = max(1, min(limit, 2000))  # 1~2000

    # 2) è®€è³‡æ–™ï¼ˆé¿å… LIMIT ? ç¶å®šå•é¡Œï¼Œé€™è£¡ç”¨å­—é¢é‡ï¼‰
    conn = get_conn()
    cur = conn.cursor()
    cur.execute(
        f"SELECT id, created_at, user_input, mode, response_json "
        f"FROM requests ORDER BY id DESC LIMIT {limit}"
    )
    rows = cur.fetchall()
    conn.close()

    # 3) æº–å‚™è¼¸å‡º
    out = StringIO()
    writer = csv.writer(out)
    writer.writerow([
        "id","created_at","mode","user_input",
        "assistant_message",
        "segments_count",
        "hook_dialog","value_dialog","cta_dialog",
        "copy_main_copy","copy_hashtags"
    ])

    for _id, created_at, user_input, mode, resp_json in rows:
        assistant_message = ""
        segments_count = ""
        hook_dialog = value_dialog = cta_dialog = ""
        copy_main = ""
        copy_hashtags = ""

        try:
            data = json.loads(resp_json or "{}")
            assistant_message = (data.get("assistant_message") or "")[:500]

            segs = data.get("segments") or []
            if isinstance(segs, list):
                segments_count = len(segs)

                def find_dialog(t):
                    tl = str(t).lower()
                    for s in segs:
                        if str(s.get("type","")).lower() == tl:
                            return s.get("dialog","")
                    return ""

                hook_dialog  = find_dialog("hook")
                value_dialog = find_dialog("value")
                cta_dialog   = find_dialog("cta")

            copy = data.get("copy") or {}
            if isinstance(copy, dict):
                copy_main = copy.get("main_copy") or ""
                tags = copy.get("hashtags") or []
                if isinstance(tags, list):
                    copy_hashtags = " ".join(map(str, tags))
        except Exception:
            # è§£æå¤±æ•—å°±ä¿æŒç©ºå­—ä¸²ï¼Œé¿å…æ•´æ”¯æ›æ‰
            pass

        writer.writerow([
            _id, created_at, mode, user_input,
            assistant_message, segments_count,
            hook_dialog, value_dialog, cta_dialog,
            copy_main, copy_hashtags
        ])

    return Response(
        content=out.getvalue(),
        media_type="text/csv",
        headers={"Content-Disposition": "inline; filename=export_flat.csv"}
    )
